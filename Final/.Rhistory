#
# 3) save the result (sd of the distributions of the means for current N) into the vector means.sds.
# You can use c() or you can use an indexing variable, in the latter case you will need to add it to the
# code and increment properly
mean.sds[i] = sd(m)
}
# at this point, you should have the vector mean.sds filled. It should have length 6 and keep the values of
# the standard deviation of the mean (known as the standard error of the mean, SEM) at different sample sizes
# (mean.sds[1] is the SEM at N=3, mean.sds[2] is the SEM at N=10, and so on)
print(mean.sds)
# let us now PLOT the SEM (i.e. the "typical" error we expect the sample mean to exhibit in any
# given experiment) as a function of the sample size, N.
plot(sample.sizes,mean.sds, main="SEM vs sample size",xlab = "Sample size", ylab = "SEM",pch=19)
lines(sample.sizes,1/sqrt(sample.sizes),col='blue')
mean.sds = numeric(0)
for (i in 1:length(sample.sizes)) { # try different sample sizes
# insert your code here (you may want to check the slides).
# 1) At each given N (i.e. in each iteration of the outer loop) you have to draw large number
# (e.g. 1000) of samples of size N from the distribution of your choice (e.g. normal, uniform, exponential, ...), calculate the mean of each of those samples and save them all into
# a vector m.
#
#m = replicate(sample.sizes[i],{mean(rnorm(1000))})
m = numeric(0)
for (j in 1:sample.sizes[i]){m[j]=rnorm(1000)}
# 2) Now, with vector m in hand, we want to characterize how much the sample mean fluctuates
# from one experiment (experiment=taking a sample of N measurements) to the next. Instead of just
# drawing a histogram, this time we will calculate the standard deviation of the distribution
# represented by the vector m. Use function sd().
#
# 3) save the result (sd of the distributions of the means for current N) into the vector means.sds.
# You can use c() or you can use an indexing variable, in the latter case you will need to add it to the
# code and increment properly
mean.sds[i] = sd(m)
}
# at this point, you should have the vector mean.sds filled. It should have length 6 and keep the values of
# the standard deviation of the mean (known as the standard error of the mean, SEM) at different sample sizes
# (mean.sds[1] is the SEM at N=3, mean.sds[2] is the SEM at N=10, and so on)
print(mean.sds)
# let us now PLOT the SEM (i.e. the "typical" error we expect the sample mean to exhibit in any
# given experiment) as a function of the sample size, N.
plot(sample.sizes,mean.sds, main="SEM vs sample size",xlab = "Sample size", ylab = "SEM",pch=19)
lines(sample.sizes,1/sqrt(sample.sizes),col='blue')
mean.sds = numeric(0)
for (i in 1:length(sample.sizes)) { # try different sample sizes
# insert your code here (you may want to check the slides).
# 1) At each given N (i.e. in each iteration of the outer loop) you have to draw large number
# (e.g. 1000) of samples of size N from the distribution of your choice (e.g. normal, uniform, exponential, ...), calculate the mean of each of those samples and save them all into
# a vector m.
#
#m = replicate(sample.sizes[i],{mean(rnorm(1000))})
m = numeric(0)
for (j in 1:sample.sizes[i]){m[j]=rnorm(1000)}
# 2) Now, with vector m in hand, we want to characterize how much the sample mean fluctuates
# from one experiment (experiment=taking a sample of N measurements) to the next. Instead of just
# drawing a histogram, this time we will calculate the standard deviation of the distribution
# represented by the vector m. Use function sd().
#
# 3) save the result (sd of the distributions of the means for current N) into the vector means.sds.
# You can use c() or you can use an indexing variable, in the latter case you will need to add it to the
# code and increment properly
mean.sds[i] = sd(m)
}
# at this point, you should have the vector mean.sds filled. It should have length 6 and keep the values of
# the standard deviation of the mean (known as the standard error of the mean, SEM) at different sample sizes
# (mean.sds[1] is the SEM at N=3, mean.sds[2] is the SEM at N=10, and so on)
print(mean.sds)
# let us now PLOT the SEM (i.e. the "typical" error we expect the sample mean to exhibit in any
# given experiment) as a function of the sample size, N.
plot(sample.sizes,mean.sds, main="SEM vs sample size",xlab = "Sample size", ylab = "SEM",pch=19)
lines(sample.sizes,1/sqrt(sample.sizes),col='blue')
mean.sds = numeric(0)
for (i in 1:length(sample.sizes)) { # try different sample sizes
# insert your code here (you may want to check the slides).
# 1) At each given N (i.e. in each iteration of the outer loop) you have to draw large number
# (e.g. 1000) of samples of size N from the distribution of your choice (e.g. normal, uniform, exponential, ...), calculate the mean of each of those samples and save them all into
# a vector m.
#
#m = replicate(sample.sizes[i],{mean(rnorm(1000))})
m = numeric(0)
for (j in 1:sample.sizes[i]){m[j]=rnorm(1000)}
# 2) Now, with vector m in hand, we want to characterize how much the sample mean fluctuates
# from one experiment (experiment=taking a sample of N measurements) to the next. Instead of just
# drawing a histogram, this time we will calculate the standard deviation of the distribution
# represented by the vector m. Use function sd().
#
# 3) save the result (sd of the distributions of the means for current N) into the vector means.sds.
# You can use c() or you can use an indexing variable, in the latter case you will need to add it to the
# code and increment properly
mean.sds[i] = sd(m)
}
# at this point, you should have the vector mean.sds filled. It should have length 6 and keep the values of
# the standard deviation of the mean (known as the standard error of the mean, SEM) at different sample sizes
# (mean.sds[1] is the SEM at N=3, mean.sds[2] is the SEM at N=10, and so on)
print(mean.sds)
# let us now PLOT the SEM (i.e. the "typical" error we expect the sample mean to exhibit in any
# given experiment) as a function of the sample size, N.
plot(sample.sizes,mean.sds, main="SEM vs sample size",xlab = "Sample size", ylab = "SEM",pch=19)
lines(sample.sizes,1/sqrt(sample.sizes),col='blue')
mean.sds = numeric(0)
for (i in 1:length(sample.sizes)) { # try different sample sizes
# insert your code here (you may want to check the slides).
# 1) At each given N (i.e. in each iteration of the outer loop) you have to draw large number
# (e.g. 1000) of samples of size N from the distribution of your choice (e.g. normal, uniform, exponential, ...), calculate the mean of each of those samples and save them all into
# a vector m.
#
#m = replicate(sample.sizes[i],{mean(rnorm(1000))})
m = numeric(0)
for (j in 1:sample.sizes[i]){m[j]=rnorm(1000)}
# 2) Now, with vector m in hand, we want to characterize how much the sample mean fluctuates
# from one experiment (experiment=taking a sample of N measurements) to the next. Instead of just
# drawing a histogram, this time we will calculate the standard deviation of the distribution
# represented by the vector m. Use function sd().
#
# 3) save the result (sd of the distributions of the means for current N) into the vector means.sds.
# You can use c() or you can use an indexing variable, in the latter case you will need to add it to the
# code and increment properly
mean.sds[i] = sd(m)
}
# at this point, you should have the vector mean.sds filled. It should have length 6 and keep the values of
# the standard deviation of the mean (known as the standard error of the mean, SEM) at different sample sizes
# (mean.sds[1] is the SEM at N=3, mean.sds[2] is the SEM at N=10, and so on)
print(mean.sds)
# let us now PLOT the SEM (i.e. the "typical" error we expect the sample mean to exhibit in any
# given experiment) as a function of the sample size, N.
plot(sample.sizes,mean.sds, main="SEM vs sample size",xlab = "Sample size", ylab = "SEM",pch=19)
lines(sample.sizes,1/sqrt(sample.sizes),col='blue')
mean.sds = numeric(0)
for (i in 1:length(sample.sizes)) { # try different sample sizes
# insert your code here (you may want to check the slides).
# 1) At each given N (i.e. in each iteration of the outer loop) you have to draw large number
# (e.g. 1000) of samples of size N from the distribution of your choice (e.g. normal, uniform, exponential, ...), calculate the mean of each of those samples and save them all into
# a vector m.
#
#m = replicate(sample.sizes[i],{mean(rnorm(1000))})
m = numeric(0)
for (j in 1:sample.sizes[i]){m[j]=rnorm(1000)}
# 2) Now, with vector m in hand, we want to characterize how much the sample mean fluctuates
# from one experiment (experiment=taking a sample of N measurements) to the next. Instead of just
# drawing a histogram, this time we will calculate the standard deviation of the distribution
# represented by the vector m. Use function sd().
#
# 3) save the result (sd of the distributions of the means for current N) into the vector means.sds.
# You can use c() or you can use an indexing variable, in the latter case you will need to add it to the
# code and increment properly
mean.sds[i] = sd(m)
}
# at this point, you should have the vector mean.sds filled. It should have length 6 and keep the values of
# the standard deviation of the mean (known as the standard error of the mean, SEM) at different sample sizes
# (mean.sds[1] is the SEM at N=3, mean.sds[2] is the SEM at N=10, and so on)
print(mean.sds)
# let us now PLOT the SEM (i.e. the "typical" error we expect the sample mean to exhibit in any
# given experiment) as a function of the sample size, N.
plot(sample.sizes,mean.sds, main="SEM vs sample size",xlab = "Sample size", ylab = "SEM",pch=19)
lines(sample.sizes,1/sqrt(sample.sizes),col='blue')
mean.sds = numeric(0)
for (i in 1:length(sample.sizes)) { # try different sample sizes
# insert your code here (you may want to check the slides).
# 1) At each given N (i.e. in each iteration of the outer loop) you have to draw large number
# (e.g. 1000) of samples of size N from the distribution of your choice (e.g. normal, uniform, exponential, ...), calculate the mean of each of those samples and save them all into
# a vector m.
#
#m = replicate(sample.sizes[i],{mean(rnorm(1000))})
m = numeric(0)
for (j in 1:sample.sizes[i]){m[j]=rnorm(1000)}
# 2) Now, with vector m in hand, we want to characterize how much the sample mean fluctuates
# from one experiment (experiment=taking a sample of N measurements) to the next. Instead of just
# drawing a histogram, this time we will calculate the standard deviation of the distribution
# represented by the vector m. Use function sd().
#
# 3) save the result (sd of the distributions of the means for current N) into the vector means.sds.
# You can use c() or you can use an indexing variable, in the latter case you will need to add it to the
# code and increment properly
mean.sds[i] = sd(m)
}
# at this point, you should have the vector mean.sds filled. It should have length 6 and keep the values of
# the standard deviation of the mean (known as the standard error of the mean, SEM) at different sample sizes
# (mean.sds[1] is the SEM at N=3, mean.sds[2] is the SEM at N=10, and so on)
print(mean.sds)
# let us now PLOT the SEM (i.e. the "typical" error we expect the sample mean to exhibit in any
# given experiment) as a function of the sample size, N.
plot(sample.sizes,mean.sds, main="SEM vs sample size",xlab = "Sample size", ylab = "SEM",pch=19)
lines(sample.sizes,1/sqrt(sample.sizes),col='blue')
mean.sds = numeric(0)
for (i in 1:length(sample.sizes)) { # try different sample sizes
# insert your code here (you may want to check the slides).
# 1) At each given N (i.e. in each iteration of the outer loop) you have to draw large number
# (e.g. 1000) of samples of size N from the distribution of your choice (e.g. normal, uniform, exponential, ...), calculate the mean of each of those samples and save them all into
# a vector m.
#
#m = replicate(sample.sizes[i],{mean(rnorm(1000))})
m = numeric(0)
for (j in 1:sample.sizes[i]){m[j]=rnorm(1000)}
# 2) Now, with vector m in hand, we want to characterize how much the sample mean fluctuates
# from one experiment (experiment=taking a sample of N measurements) to the next. Instead of just
# drawing a histogram, this time we will calculate the standard deviation of the distribution
# represented by the vector m. Use function sd().
#
# 3) save the result (sd of the distributions of the means for current N) into the vector means.sds.
# You can use c() or you can use an indexing variable, in the latter case you will need to add it to the
# code and increment properly
mean.sds[i] = sd(m)
}
# at this point, you should have the vector mean.sds filled. It should have length 6 and keep the values of
# the standard deviation of the mean (known as the standard error of the mean, SEM) at different sample sizes
# (mean.sds[1] is the SEM at N=3, mean.sds[2] is the SEM at N=10, and so on)
print(mean.sds)
# let us now PLOT the SEM (i.e. the "typical" error we expect the sample mean to exhibit in any
# given experiment) as a function of the sample size, N.
plot(sample.sizes,mean.sds, main="SEM vs sample size",xlab = "Sample size", ylab = "SEM",pch=19)
lines(sample.sizes,1/sqrt(sample.sizes),col='blue')
mean.sds = numeric(0)
for (i in 1:length(sample.sizes)) { # try different sample sizes
# insert your code here (you may want to check the slides).
# 1) At each given N (i.e. in each iteration of the outer loop) you have to draw large number
# (e.g. 1000) of samples of size N from the distribution of your choice (e.g. normal, uniform, exponential, ...), calculate the mean of each of those samples and save them all into
# a vector m.
#
#m = replicate(sample.sizes[i],{mean(rnorm(1000))})
m = numeric(0)
for (j in 1:sample.sizes[i]){m[j]=rnorm(1000)}
# 2) Now, with vector m in hand, we want to characterize how much the sample mean fluctuates
# from one experiment (experiment=taking a sample of N measurements) to the next. Instead of just
# drawing a histogram, this time we will calculate the standard deviation of the distribution
# represented by the vector m. Use function sd().
#
# 3) save the result (sd of the distributions of the means for current N) into the vector means.sds.
# You can use c() or you can use an indexing variable, in the latter case you will need to add it to the
# code and increment properly
mean.sds[i] = sd(m)
}
# at this point, you should have the vector mean.sds filled. It should have length 6 and keep the values of
# the standard deviation of the mean (known as the standard error of the mean, SEM) at different sample sizes
# (mean.sds[1] is the SEM at N=3, mean.sds[2] is the SEM at N=10, and so on)
print(mean.sds)
# let us now PLOT the SEM (i.e. the "typical" error we expect the sample mean to exhibit in any
# given experiment) as a function of the sample size, N.
plot(sample.sizes,mean.sds, main="SEM vs sample size",xlab = "Sample size", ylab = "SEM",pch=19)
lines(sample.sizes,1/sqrt(sample.sizes),col='blue')
mean.sds = numeric(0)
for (i in 1:length(sample.sizes)) { # try different sample sizes
# insert your code here (you may want to check the slides).
# 1) At each given N (i.e. in each iteration of the outer loop) you have to draw large number
# (e.g. 1000) of samples of size N from the distribution of your choice (e.g. normal, uniform, exponential, ...), calculate the mean of each of those samples and save them all into
# a vector m.
#
m = replicate(sample.sizes[i],{mean(rnorm(10000))})
# 2) Now, with vector m in hand, we want to characterize how much the sample mean fluctuates
# from one experiment (experiment=taking a sample of N measurements) to the next. Instead of just
# drawing a histogram, this time we will calculate the standard deviation of the distribution
# represented by the vector m. Use function sd().
#
# 3) save the result (sd of the distributions of the means for current N) into the vector means.sds.
# You can use c() or you can use an indexing variable, in the latter case you will need to add it to the
# code and increment properly
mean.sds[i] = sd(m)
}
# at this point, you should have the vector mean.sds filled. It should have length 6 and keep the values of
# the standard deviation of the mean (known as the standard error of the mean, SEM) at different sample sizes
# (mean.sds[1] is the SEM at N=3, mean.sds[2] is the SEM at N=10, and so on)
print(mean.sds)
plot(sample.sizes,mean.sds, main="SEM vs sample size",xlab = "Sample size", ylab = "SEM",pch=19)
lines(sample.sizes,1/sqrt(sample.sizes),col='blue')
1/sqrt(1000)
for (i in 1:length(sample.sizes)) { # try different sample sizes
# insert your code here (you may want to check the slides).
# 1) At each given N (i.e. in each iteration of the outer loop) you have to draw large number
# (e.g. 1000) of samples of size N from the distribution of your choice (e.g. normal, uniform, exponential, ...), calculate the mean of each of those samples and save them all into
# a vector m.
#
N = sample.sizes[i]
print(N)
m = replicate(sample.sizes[i],{mean(rnorm(10000))})
# 2) Now, with vector m in hand, we want to characterize how much the sample mean fluctuates
# from one experiment (experiment=taking a sample of N measurements) to the next. Instead of just
# drawing a histogram, this time we will calculate the standard deviation of the distribution
# represented by the vector m. Use function sd().
#
# 3) save the result (sd of the distributions of the means for current N) into the vector means.sds.
# You can use c() or you can use an indexing variable, in the latter case you will need to add it to the
# code and increment properly
mean.sds[i] = sd(m)
}
for (i in 1:length(sample.sizes)) { # try different sample sizes
# insert your code here (you may want to check the slides).
# 1) At each given N (i.e. in each iteration of the outer loop) you have to draw large number
# (e.g. 1000) of samples of size N from the distribution of your choice (e.g. normal, uniform, exponential, ...), calculate the mean of each of those samples and save them all into
# a vector m.
#
N = sample.sizes[i]
m = replicate(N,{mean(rnorm(10000))})
# 2) Now, with vector m in hand, we want to characterize how much the sample mean fluctuates
# from one experiment (experiment=taking a sample of N measurements) to the next. Instead of just
# drawing a histogram, this time we will calculate the standard deviation of the distribution
# represented by the vector m. Use function sd().
#
# 3) save the result (sd of the distributions of the means for current N) into the vector means.sds.
# You can use c() or you can use an indexing variable, in the latter case you will need to add it to the
# code and increment properly
mean.sds[i] = sd(m)
}
print(mean.sds)
plot(sample.sizes,mean.sds, main="SEM vs sample size",xlab = "Sample size", ylab = "SEM",pch=19)
lines(sample.sizes,1/sqrt(sample.sizes),col='blue')
mean.sds = numeric(0)
for (i in 1:length(sample.sizes)) { # try different sample sizes
# insert your code here (you may want to check the slides).
# 1) At each given N (i.e. in each iteration of the outer loop) you have to draw large number
# (e.g. 1000) of samples of size N from the distribution of your choice (e.g. normal, uniform, exponential, ...), calculate the mean of each of those samples and save them all into
# a vector m.
#
N = sample.sizes[i]
m = replicate(1000,{mean(rnorm(N))})
# 2) Now, with vector m in hand, we want to characterize how much the sample mean fluctuates
# from one experiment (experiment=taking a sample of N measurements) to the next. Instead of just
# drawing a histogram, this time we will calculate the standard deviation of the distribution
# represented by the vector m. Use function sd().
#
# 3) save the result (sd of the distributions of the means for current N) into the vector means.sds.
# You can use c() or you can use an indexing variable, in the latter case you will need to add it to the
# code and increment properly
mean.sds[i] = sd(m)
}
# at this point, you should have the vector mean.sds filled. It should have length 6 and keep the values of
# the standard deviation of the mean (known as the standard error of the mean, SEM) at different sample sizes
# (mean.sds[1] is the SEM at N=3, mean.sds[2] is the SEM at N=10, and so on)
print(mean.sds)
# let us now PLOT the SEM (i.e. the "typical" error we expect the sample mean to exhibit in any
# given experiment) as a function of the sample size, N.
plot(sample.sizes,mean.sds, main="SEM vs sample size",xlab = "Sample size", ylab = "SEM",pch=19)
lines(sample.sizes,1/sqrt(sample.sizes),col='blue')
N = 1  # the number of i.i.d. variables X we are going to sum
# how many times we are going to repeat the "experiment" (see the text above for what we call an experiment):
repeats = 1000
s.values=numeric() # we will use this vector to store the value of the sum in each experiment
for (n.exp in 1:repeats) { # repeat the experiment!
# explained below. Here we must draw the values x1, ..., xN of the random variables we are going to sum up:
x = rbinom(N,.5)
### replace with correct call: x = DISTR(N,...)
# the "measured" value of the random variable X is the sum of x1...xN, calculate it and save into
# the vector s.values:
### replace with correct call: s.values[n.exp] = ...???...
s.values[n.exp] = sum(x)
}
# we repeated the experiment 1000 times, so we have 1000 values sampled from the process S and that should
# be plenty for looking at their distribution:
### replace with correct call:   ...DRAW histogram of n.exp values of s.values...
hist(s.values)
N = 1  # the number of i.i.d. variables X we are going to sum
# how many times we are going to repeat the "experiment" (see the text above for what we call an experiment):
repeats = 1000
s.values=numeric() # we will use this vector to store the value of the sum in each experiment
for (n.exp in 1:repeats) { # repeat the experiment!
# explained below. Here we must draw the values x1, ..., xN of the random variables we are going to sum up:
x = rbinom(N,10,.5)
### replace with correct call: x = DISTR(N,...)
# the "measured" value of the random variable X is the sum of x1...xN, calculate it and save into
# the vector s.values:
### replace with correct call: s.values[n.exp] = ...???...
s.values[n.exp] = sum(x)
}
# we repeated the experiment 1000 times, so we have 1000 values sampled from the process S and that should
# be plenty for looking at their distribution:
### replace with correct call:   ...DRAW histogram of n.exp values of s.values...
hist(s.values)
sample <- function(N) {# the number of i.i.d. variables X we are going to sum
# how many times we are going to repeat the "experiment" (see the text above for what we call an experiment):
repeats = 1000
s.values=numeric() # we will use this vector to store the value of the sum in each experiment
for (n.exp in 1:repeats) { # repeat the experiment!
# explained below. Here we must draw the values x1, ..., xN of the random variables we are going to sum up:
x = rbinom(N,10,.5)
### replace with correct call: x = DISTR(N,...)
# the "measured" value of the random variable X is the sum of x1...xN, calculate it and save into
# the vector s.values:
### replace with correct call: s.values[n.exp] = ...???...
s.values[n.exp] = sum(x)
return (s.values)
}
# we repeated the experiment 1000 times, so we have 1000 values sampled from the process S and that should
# be plenty for looking at their distribution:
### replace with correct call:   ...DRAW histogram of n.exp values of s.values...
}
n_1 = sample(1)
hist(n_1)
sample <- function(N) {
repeats = 1000
s.values=numeric()
for (n.exp in 1:repeats) {
x = rbinom(N,10,.5)
}
return (s.values)
}
n_1 = sample(1)
hist(n_1)
sample <- function(N) {
repeats = 1000
s.values=numeric()
for (n.exp in 1:repeats) {
s.values[n.exp] = rbinom(N,10,.5)
}
return (s.values)
}
n_1 = sample(1)
hist(n_1)
n_5 = sample(5)
hist(n_5)
sample <- function(N) {
repeats = 1000
s.values=numeric()
for (n.exp in 1:repeats) {
s.values[n.exp] = rbinom(N,1,.5)
}
return (s.values)
}
n_1 = sample(1)
hist(n_1)
n_5 = sample(5)
hist(n_5)
n_5 = sample(5)
hist(n_5)
sample <- function(N) {
repeats = 1000
s.values=numeric()
for (n.exp in 1:repeats) {
s.values[n.exp] = rbinom(N,2,.5)
}
return (s.values)
}
n_1 = sample(1)
hist(n_1)
n_5 = sample(5)
hist(n_5)
sample <- function(N) {
repeats = 1000
s.values=numeric()
for (n.exp in 1:repeats) {
s.values[n.exp] = rbinom(N,8,.5)
}
return (s.values)
}
n_1 = sample(1)
hist(n_1)
sample <- function(N) {
repeats = 1000
s.values=numeric()
for (n.exp in 1:repeats) {
s.values[n.exp] = runif(N)
}
return (s.values)
}
n_1 = sample(1)
hist(n_1)
n_5 = sample(5)
hist(n_5)
sample <- function(N) {
repeats = 1000
s.values=numeric()
for (n.exp in 1:repeats) {
s.values[n.exp] = sum(runif(N))
}
return (s.values)
}
n_1 = sample(1)
hist(n_1)
n_5 = sample(5)
hist(n_5)
sample <- function(N) {
repeats = 1000
s.values=numeric()
for (n.exp in 1:repeats) {
s.values[n.exp] = sum(runif(N))
}
return (s.values)
}
n_1 = sample(1)
hist(n_1)
n_5 = sample(5)
hist(n_5)
n_1 = sample(1)
hist(n_1, main = "Uniform distribution: N=1")
n_2 = sample(2)
hist(n_2,main = "Uniform distribution: N=2")
n_5 = sample(5)
hist(n_5,main = "Uniform distribution: N=5")
n_10 = sample(10)
hist(n_5,main = "Uniform distribution: N=10")
habDat <- read.table("haberman.data",sep=",")
habDat <- read.table("haberman.data",sep=",")
getwd()
set.seed(34343)
ttrain <- train[sample(nrow(train), 3000), ]
setwd("/Users/bear/Studies/Harvard/ESLR/Final")
train <- read.table("train.csv")
set.seed(34343)
ttrain <- train[sample(nrow(train), 3000), ]
ctrl <- trainControl(method="repeatedcv",repeats = 3)
library(caret)
set.seed(400)
ctrl <- trainControl(method="repeatedcv",repeats = 3)
knnFit <- train(Class ~ ., data = ttrain, method = "knn", trControl = ctrl, preProcess = c("center","scale"), tuneLength = 20)
knnFit <- train(class ~ ., data = ttrain, method = "knn", trControl = ctrl, preProcess = c("center","scale"), tuneLength = 20)
knnFit <- train(class ~ ., data = train, method = "knn", trControl = ctrl, preProcess = c("center","scale"), tuneLength = 20)
knnFit
knnFit <- train(class ~ ., data = train, method = "knn", trControl = ctrl, preProcess = c("center","scale"), tuneLength = 10)
set.seed(400)
set.seed(34343)
ttrain <- train[sample(nrow(train), 5000), ]
knnFit <- train(class ~ ., data = ttrain, method = "knn", trControl = ctrl, preProcess = c("center","scale"), tuneLength = 10)
ttrain <- train[sample(nrow(train), 10000), ]
ctrl <- trainControl(method="repeatedcv",repeats = 3)
knnFit <- train(class ~ ., data = ttrain, method = "knn", trControl = ctrl, preProcess = c("center","scale"), tuneLength = 10)
knnFit
